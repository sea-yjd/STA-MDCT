import os, sys
os.environ['CUDA_VISIBLE_DEVICES'] = '0'
from torch.utils.data import DataLoader
from scipy.io.wavfile import write
import torch
import torchaudio
import numpy as np
import pickle
import yaml
from pytorch_lightning import LightningModule, Trainer

current_path = os.path.dirname(os.path.abspath(__file__))
parent_path = os.path.dirname(current_path)
if parent_path not in sys.path:
    sys.path.append(parent_path)
from dataset.Dataset import Dataset
from defense.defense import parser_defense
from tqdm import tqdm
from attack.FGSM import FGSM
from attack.PGD import PGD
from attack.CWinf import CWinf
from attack.CW2 import CW2
from attack.S2A import S2A
from attack.ACG import ACG
from attack.AoA import AoA

from speaker_trainer.module import Model
from speaker_trainer.module_visualization import Model_visualization
from set_threshold import Load_enroll_spk_embedding

device = 'cuda' if torch.cuda.is_available() else 'cpu'
bits = 16

def parse_args():
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument('--farthest_target_id', action='store_true', default=True)

    # true threshold and threshold estimation
    # parser.add_argument('-threshold', type=float, default=18.72) # for SV/OSI task; real threshold of the model
    parser.add_argument('--threshold_estimated', type=float, default=None) # for SV/OSI task; estimated threshold by FAKEBOB
    parser.add_argument('--thresh_est_wav_path', type=str, nargs='+', default=None) # the audio path used to estimate the threshold, should from imposter (initially rejected)
    parser.add_argument('--thresh_est_step', type=float, default=0.1) # the smaller, the accurate, but the slower
    
    #### add a defense layer in the model
    #### Note that for white-box attack, the defense method needs to be differentiable
    parser.add_argument('--defense', nargs='+', default=None)
    parser.add_argument('--defense_param', nargs='+', default=["kmeans 0.2 L2"])
    parser.add_argument('--defense_flag', nargs='+', default=[1], type=int)
    parser.add_argument('--defense_order', default='sequential', choices=['sequential', 'average'])

    parser.add_argument('--root', type=str,  default='./data')
    parser.add_argument('--name', type=str,  default='')
    parser.add_argument('--des', type=str, default='./adver-audio/xv-pgd') # path to store adver audios
    parser.add_argument('--task', type=str, default='CSI', choices=['CSI', 'SV', 'OSI']) # the attack use this to set the loss function
    parser.add_argument('--wav_length', type=int, default=None)

    ## common attack parameters
    parser.add_argument('--targeted', action='store_true', default=True)
    parser.add_argument('--target', type=int, default=2)
    parser.add_argument('--target_label_file', default='') # the path of the file containing the target label; generated by set_target_label.py
    parser.add_argument('--batch_size', type=int, default=1)
    parser.add_argument('--EOT_size', type=int, default=1)
    parser.add_argument('--EOT_batch_size', type=int, default=1)
    parser.add_argument('--start', type=int, default=0)
    parser.add_argument('--end', type=int, default=-1)
    parser.add_argument('--confidence', type=float, default=0)    # TODO
    parser.add_argument('--loss', type=str, choices=['Entropy', 'Margin'], default='Margin')
    parser.add_argument('--is_mel', action='store_true', default=False)     # TODO

    # parser.add_argument('--attacker', default='PGD')
    # parser.add_argument('--step_size', type=float, default=2)
    # parser.add_argument('--epsilon', type=float, default=46)
    # parser.add_argument('--max_iter', type=int, default=25) # PGD-10 default   25
    # parser.add_argument('--num_random_init', type=int, default=0)
    # parser.add_argument('--attack_transform', type=str, default='NI', choices=['I', 'MI', 'TI', 'DI','NI'])
    # parser.add_argument("--momentum", type=float, default=1.0, help="Momentum")

    parser.add_argument('--attacker', default='S2A')
    parser.add_argument('--max_iter', type=int, default=10)
    parser.add_argument('--epsilon', type=float, default=60)
    parser.add_argument('--N', type=int, default=20)
    parser.add_argument('--s_rho', help='Tuning factor', type=float, default=0.75)
    parser.add_argument("--momentum", type=float, default=1.0, help="Momentum")
    parser.add_argument("--alpha", type=float, default=6)
    parser.add_argument("--sigma", type=float, default=44.0, help="Std of random noise")
    parser.add_argument('--spectrum_transform_type', type=str, default='MDCT', help='', choices=['MDCT', 'DCT','FFT','Time'])
    parser.add_argument('--attack_transform', type=str, default='I', choices=['I', 'MI', 'TI', 'DI','NI'])

    # parser.add_argument('--attacker', default='AoA')
    # parser.add_argument('--max_iter', type=int, default=10)
    # parser.add_argument('--epsilon', type=float, default=60)
    # parser.add_argument("--alpha", type=float, default=6)

    # parser.add_argument('--attacker', default='FGSM')
    # parser.add_argument("--epsilon", type=float, default=35)

    # parser.add_argument('--attacker', default='ACG')
    # parser.add_argument('--max_iter', type=int, default=20)
    # parser.add_argument('--epsilon', type=float, default=42)
    # parser.add_argument('--rho', type=float, default=0.75)
    # parser.add_argument('--W_set', help='', type=list, default=[5,10,15])
    # parser.add_argument("--alpha", type=float, default=3)
    # parser.add_argument('--eta', type=float, default=2.0)

    parser = Trainer.add_argparse_args(parser)
    parser = Model.add_model_specific_args(parser)
    args = parser.parse_args()
    if args.nnet_type == 'RawNet3':
        args.config = parent_path + '/Attack_for_ASV/SpeakerVerification/pretrained_model/RawNet3.yaml'
    elif args.nnet_type == 'ECAPATDNN':
        args.config = parent_path + '/Attack_for_ASV/SpeakerVerification/pretrained_model/ECAPATDNN.yaml'
    elif args.nnet_type == 'ResNetSE34L':
        args.config = parent_path + '/Attack_for_ASV/SpeakerVerification/pretrained_model/ResNetSE34L.yaml'
    elif args.nnet_type == 'ResNetSE34V2':
        args.config = parent_path + '/Attack_for_ASV/SpeakerVerification/pretrained_model/ResNetSE34V2.yaml'
    elif args.nnet_type == 'AdverTraining_ECAPATDNN':
        args.config = parent_path + '/Attack_for_ASV/SpeakerVerification/pretrained_model/Adver_training_ECAPATDNN.yaml'
    elif args.nnet_type == 'SpecAug_ResNetSE34L':
        args.config = parent_path + '/Attack_for_ASV/SpeakerVerification/pretrained_model/SpecAug_ResNetSE34L.yaml'
        
    ## Parse YAML
    def find_option_type(key, parser):
        for opt in parser._get_optional_actions():
            if ('--' + key) in opt.option_strings:
                return opt.type
        raise ValueError
    if args.config is not None:
        with open(args.config, "r") as f:
            yml_config = yaml.load(f, Loader=yaml.FullLoader)
        for k, v in yml_config.items():
            if k in args.__dict__:
                typ = find_option_type(k, parser)
                args.__dict__[k] = typ(v)
            else:
                sys.stderr.write("Ignored unknown parameter {} in yaml.\n".format(k))
    return args

def save_audio(advers, names, root, fs=16000):
    advers = advers.reshape(1, 1, -1)
    for adver, name in zip(advers[:, 0, :], names):
        if 0.9 * adver.max() <= 1 and 0.9 * adver.min() >= -1:
            adver = adver * (2 ** (bits-1))
        if type(adver) == torch.Tensor:
            adver = adver.detach().cpu().numpy()
        adver = adver.astype(np.int16)
        spk_id = name.split("-")[0]
        spk_dir = os.path.join(root, spk_id)
        if not os.path.exists(spk_dir):
            os.makedirs(spk_dir)
        adver_path = os.path.join(spk_dir, name + ".wav")
        write(adver_path, fs, adver)
        
# get target id
def get_target_attack_id(model, loader, enroll_embedding):
    farest_target_id = {}
    for index, (origin, true, file_name) in enumerate(tqdm(loader)):
        origin = origin.to(device)
        true = true.to(device)
        target = model.get_farthest_target_id(origin, enroll_embedding, true)
        farest_target_id[file_name] = target.item()
    
    farest_target_id = {key[0]: value for key, value in farest_target_id.items()}
    with open('Target_label/ECAPATDNN-OSI-farthest_target_label.pkl', 'wb') as file:
        pickle.dump(farest_target_id, file)
            
def main(args):
    args.enroll_embedding = Load_enroll_spk_embedding(args.root, args.nnet_type)
    
    if args.task == 'CSI':
        args.target_label_file = 'Target_label/ECAPATDNN-CSI-farthest_target_label.pkl'
        args.name = 'Spk10_test'
    elif args.task == 'OSI':
        args.target_label_file = 'Target_label/ECAPATDNN-OSI-farthest_target_label.pkl'
        args.name = 'Spk10_imposter'
    model = Model(**vars(args))
    # model = Model_visualization(**vars(args))
    args.checkpoint_path = parent_path + '/Attack_for_ASV/' + args.checkpoint_path
    if args.checkpoint_path is not None:
        state_dict = torch.load(args.checkpoint_path)
        # pop loss Function parameter
        loss_weights = []
        for key, value in state_dict.items():
            if "loss" in key:
                loss_weights.append(key)
        for item in loss_weights:
            state_dict.pop(item)
        self_state = model.state_dict()
        for name, param in state_dict.items():
            origname = name
            if name not in self_state:
                name = name.replace("speaker_encoder", "__S__")

                if name not in self_state:
                    print("{} is not in the model.".format(origname))
                    continue

            if self_state[name].size() != state_dict[origname].size():
                print("Wrong parameter length: {}, model: {}, loaded: {}".format(origname, self_state[name].size(), state_dict[origname].size()));
                continue

            self_state[name].copy_(param)
        print("initial parameter from pretrain model {}".format(args.checkpoint_path))
    
    model.eval().cuda()

    defense, defense_name = parser_defense(args.defense, args.defense_param, args.defense_flag, args.defense_order)
    enroll_dir = os.path.join(args.root, 'Spk10_enroll')
    spk_ids = os.listdir(enroll_dir)
    spk_ids.sort()
    wav_length = None if args.batch_size == 1 else args.wav_length
    # dataset = getattr(sys.modules[__name__], args.name)(spk_ids, root, return_file_name=True, wav_length=wav_length)
    # # set normalize to True since adv voices generated at [-1, 1] float domain
    dataset = Dataset(spk_ids, args.root, args.name, normalize=False, return_file_name=True, wav_length=wav_length)
    loader = DataLoader(dataset, batch_size=args.batch_size, num_workers=0)
    # get_target_attack_id(model, loader, args.enroll_embedding)
        
    if args.task == 'OSI':
        if args.nnet_type == 'ECAPATDNN':
            args.threshold = 0.51
        elif args.nnet_type == 'ResNetSE34L':
            args.threshold = 0.72
        elif args.nnet_type == 'ResNetSE34V2':
            args.threshold = 0.57
        elif args.nnet_type == 'RawNet3':
            args.threshold = 0.49
    if args.task == 'CSI':
        args.threshold = 0
    # deal with black-box threshold (in black-box attack, the attacker does not know the true threshold)
    attacker = None
    if args.attacker == 'FGSM':
        attacker = FGSM(model, task=args.task, epsilon=args.epsilon, loss=args.loss, targeted=args.targeted, 
                        batch_size=args.batch_size, EOT_size=args.EOT_size, EOT_batch_size=args.EOT_batch_size, threshold=args.threshold, enroll_embedding = args.enroll_embedding, confidence=args.confidence,verbose=1)
    elif args.attacker == 'PGD':
        attacker = PGD(model, task=args.task, targeted=args.targeted, step_size=args.step_size,
                       epsilon=args.epsilon, max_iter=args.max_iter,
                       batch_size=args.batch_size, num_random_init=args.num_random_init,
                       loss=args.loss, EOT_size=args.EOT_size, EOT_batch_size=args.EOT_batch_size,threshold=args.threshold, target=args.target, 
                       enroll_embedding = args.enroll_embedding, confidence=args.confidence, attack_transform=args.attack_transform, momentum=args.momentum,
                       verbose=1)
    elif args.attacker == 'CWinf':
        attacker = CWinf(model, task=args.task, targeted=args.targeted, step_size=args.step_size,
                       epsilon=args.epsilon, max_iter=args.max_iter,
                       batch_size=args.batch_size, num_random_init=args.num_random_init,
                       loss=args.loss, EOT_size=args.EOT_size, EOT_batch_size=args.EOT_batch_size, verbose=1)
    elif args.attacker == 'CW2':
        attacker = CW2(model, task=args.task, initial_const=args.initial_const, binary_search_steps=args.binary_search_steps,
                            max_iter=args.max_iter, stop_early=args.stop_early, stop_early_iter=args.stop_early_iter, lr=args.lr,
                            targeted=args.targeted, confidence=args.confidence, verbose=1, batch_size=args.batch_size
                            )
    elif args.attacker == 'S2A':
        attacker = S2A(model, task=args.task, targeted=args.targeted, max_iter=args.max_iter, epsilon=args.epsilon,
                        N=args.N, s_rho=args.s_rho, momentum=args.momentum, alpha=args.alpha, sigma=args.sigma, 
                        spectrum_transform_type=args.spectrum_transform_type, attack_transform=args.attack_transform,
                        batch_size=args.batch_size,
                       loss=args.loss, EOT_size=args.EOT_size, EOT_batch_size=args.EOT_batch_size,threshold=args.threshold,
                       enroll_embedding = args.enroll_embedding, confidence=args.confidence,
                       verbose=1)
    elif args.attacker == 'ACG':
        attacker = ACG(model, task=args.task, targeted=args.targeted, max_iter=args.max_iter, epsilon=args.epsilon,
                        rho=args.rho, W_set=args.W_set, alpha=args.alpha, confidence=args.confidence, loss=args.loss, 
                        eta =args.eta, EOT_size=args.EOT_size, EOT_batch_size=args.EOT_batch_size,threshold=args.threshold,
                       enroll_embedding = args.enroll_embedding, batch_size=args.batch_size, verbose=1)
    elif args.attacker == 'AoA':
        attacker = AoA(model, task=args.task, targeted=args.targeted, max_iter=args.max_iter, epsilon=args.epsilon,
                        alpha=args.alpha, batch_size=args.batch_size,
                        loss=args.loss, EOT_size=args.EOT_size, EOT_batch_size=args.EOT_batch_size,threshold=args.threshold,
                        enroll_embedding = args.enroll_embedding, confidence=args.confidence,
                        verbose=1)
    else:
        raise NotImplementedError('Not Supported Attack Algorithm')

    attacker_param = None
    if args.attacker == 'FGSM':
        # attacker_param = [args.epsilon, args.confidence, args.EOT_size]
        attacker_param = 'eps' + str(args.epsilon) + '-conf' + str(args.confidence)
    elif args.attacker == 'PGD':
        # attacker_param = [args.max_iter, args.epsilon, args.step_size, args.confidence, args.num_random_init, args.EOT_size]
        attacker_param = 'iter' + str(args.max_iter) + '-eps' + str(args.epsilon) + '-step' + str(args.step_size) + '-conf' + str(args.confidence) + '-' + str(args.attack_transform) + str(args.momentum)   
    elif args.attacker == 'CWinf':
        attacker_param = [args.max_iter, args.epsilon, args.num_random_init, args.EOT_size]
    elif args.attacker == 'CW2':
        attacker_param = [args.initial_const, args.confidence, args.max_iter, args.stop_early_iter] 
    elif args.attacker == 'S2A':
        # attacker_param = [args.max_iter, args.epsilon, args.N, args.alpha, args.sigma, args.s_rho, args.confidence, args.spectrum_transform_type]
        attacker_param = 'iter' + str(args.max_iter) + '-eps' + str(args.epsilon) + '-N' + str(args.N) + '-alpha' + str(args.alpha) + '-sigma' \
                            + str(args.sigma) + '-s_rho' + str(args.s_rho) + '-conf' + str(args.confidence) + '-T' + str(args.spectrum_transform_type)   
    elif args.attacker == 'ACG':
        # attacker_param = [args.max_iter, args.epsilon, args.rho, args.alpha, args.eta, args.confidence]
        attacker_param = 'iter' + str(args.max_iter) + '-eps' + str(args.epsilon) + '-rho' + str(args.rho) +  '-alpha' + str(args.alpha) + '-eta' + str(args.eta) + '-conf' + str(args.confidence)
    elif args.attacker == 'AoA':
        attacker_param = [args.max_iter, args.epsilon, args.alpha, args.confidence]
    else:
        raise NotImplementedError('Not Supported Attack Algorithm')


    adver_dir = "./adver-audio-rebuttal-farthest/{}-{}-{}/{}/{}/{}-{}".format(args.nnet_type, args.task, args.name,
                defense_name, args.attacker, 
                args.attacker, attacker_param)
    # if args.des is not None:
    #     adver_dir = args.des
    print(adver_dir)

    # load target label
    name2target = {}
    if args.target_label_file is not None:
        with open(args.target_label_file, 'rb') as reader:
            name2target = pickle.load(reader)
    
    start = min(max(args.start, 0), len(loader))
    end =  len(loader) if args.end == -1 else args.end
    end = min(max(end, 0), len(loader))
    print(start, end)

    
    success_cnt = 0
    for index, (origin, true, file_name) in enumerate(tqdm(loader)):
        if index not in range(start, end):
            continue

        des_path = os.path.join(adver_dir, file_name[0].split('-')[0], file_name[0] + '.wav')
        if os.path.exists(des_path):
            print('*' * 40, index, file_name[0], 'Exists, SKip', '*' * 40)
            continue

        origin = origin.to(device)
        true = true.to(device)
        if args.targeted:
            # if args.farthest_target_id:
                # target = model.get_farthest_target_id(origin, args.enroll_embedding, true)
            # else:
            target = true.clone()
            for ii, y in enumerate(true):
                if file_name[ii] in name2target.keys():
                    target[ii] = name2target[file_name[ii]]
                else:
                    candidate_target_labels = list(range(len(spk_ids)))
                    if args.task == 'OSI':
                        candidate_target_labels.append(-1) # -1: reject
                    if y in candidate_target_labels:
                        candidate_target_labels.remove(y)
                    target[ii] = np.random.choice(candidate_target_labels)
            true_target = target
        print('*' * 10, index, '*' * 10)
        adver, success = attacker.attack(origin, true_target, true)
        save_audio(adver, file_name, adver_dir)
        success_cnt += sum(success)
    
    total_cnt = len(dataset)
    print(args.defense, args.defense_param, args.attacker, attacker_param, 'success rate: %f' % (success_cnt * 100 / total_cnt)) 

if __name__ == "__main__":
    main(parse_args())
